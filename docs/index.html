import React, { useState, useEffect } from 'react';
import { GameState, Faction, Character, Cell, WeaponCard } from './types/game';
import { FactionSelection } from './components/FactionSelection';
import { GameBoard } from './components/GameBoard';
import { CharacterPanel } from './components/CharacterPanel';
import { ActionPanel } from './components/ActionPanel';
import { GameOverScreen } from './components/GameOverScreen';
import {
  createCharacter,
  createBoard,
  rollDice,
  rollAbilityDice,
  getRandomWeaponCard,
  getRandomEvent,
  applyDamage,
  healCharacter,
  addShield,
  checkWinCondition,
  calculateFinalWinner,
  getCharacterAtPosition,
  isAdjacentPosition,
  FACTION_NAMES,
} from './utils/gameLogic';
import { calculateAIMove, getAIBenefitChoice } from './utils/aiLogic';
import { toast, Toaster } from 'sonner@2.0.3';

export default function App() {
  const [gameState, setGameState] = useState<GameState>({
    phase: 'faction-selection',
    turn: 'player',
    turnCount: 1,
    playerFaction: null,
    aiFaction: null,
    playerCharacters: [],
    aiCharacters: [],
    board: [],
    playerCards: [],
    aiCards: [],
    diceResult: null,
    abilityDiceResult: null,
    selectedCharacter: null,
    actionPhase: 'select-character',
    selectedAction: null,
    winner: null,
    eventActivated: false,
    currentEvent: null,
    message: 'Selecciona tu facción para comenzar',
    benefitUsedThisTurn: false,
    captureAttemptsThisTurn: 0,
  });

  // Handle faction selection
  const handleFactionSelection = (faction: Faction) => {
    const availableFactions: Faction[] = ['autobots', 'decepticons', 'primals', 'mercenarios'];
    const aiFaction = availableFactions.filter(f => f !== faction)[Math.floor(Math.random() * 3)];
    
    const playerChars = [
      createCharacter(faction, 'leader', 0),
      createCharacter(faction, 'soldier', 1),
    ];
    
    const aiChars = [
      createCharacter(aiFaction, 'leader', 15),
      createCharacter(aiFaction, 'soldier', 16),
    ];
    
    const board = createBoard();
    
    setGameState({
      ...gameState,
      phase: 'game',
      playerFaction: faction,
      aiFaction,
      playerCharacters: playerChars,
      aiCharacters: aiChars,
      board,
      message: `¡La batalla comienza! ${FACTION_NAMES[faction]} vs ${FACTION_NAMES[aiFaction]}. Selecciona un personaje para mover.`,
      actionPhase: 'select-character',
      selectedAction: null,
      benefitUsedThisTurn: false,
      captureAttemptsThisTurn: 0,
    });
    
    toast.success(`Has seleccionado ${FACTION_NAMES[faction]}`);
  };

  // Handle character selection
  const handleSelectCharacter = (characterId: string) => {
    const character = gameState.playerCharacters.find(c => c.id === characterId);
    
    if (!character || !character.isAlive) {
      toast.error('Este personaje no está disponible');
      return;
    }
    
    setGameState({
      ...gameState,
      selectedCharacter: characterId,
      actionPhase: 'choose-action',
      message: `${character.name} seleccionado. ¿Deseas atacar o moverte?`,
    });
    
    toast.info(`${character.name} seleccionado`);
  };

  // Handle action choice (attack or move)
  const handleChooseAction = (action: 'attack' | 'move') => {
    const character = gameState.playerCharacters.find(c => c.id === gameState.selectedCharacter);
    
    if (!character) return;
    
    if (action === 'attack') {
      // Check if player has cards to attack
      if (gameState.playerCards.length === 0) {
        toast.error('No tienes cartas para atacar');
        return;
      }
      
      // Check if there are adjacent enemies
      const adjacentEnemy = gameState.aiCharacters.find(ai =>
        ai.isAlive && isAdjacentPosition(character.position, ai.position)
      );
      
      if (!adjacentEnemy) {
        toast.error('No hay enemigos adyacentes para atacar');
        return;
      }
      
      setGameState({
        ...gameState,
        selectedAction: 'attack',
        actionPhase: 'action',
        message: `${character.name} preparado para atacar. Selecciona una carta.`,
      });
      
      toast.info('Modo ataque activado');
    } else {
      setGameState({
        ...gameState,
        selectedAction: 'move',
        actionPhase: 'roll-dice',
        message: `${character.name} listo para moverse. Lanza el dado.`,
      });
      
      toast.info('Modo movimiento activado');
    }
  };

  // Handle player rolling movement dice
  const handleRollDice = () => {
    if (gameState.actionPhase !== 'roll-dice') {
      toast.error('Primero selecciona un personaje');
      return;
    }
    
    const selectedChar = gameState.playerCharacters.find(c => c.id === gameState.selectedCharacter);
    
    if (!selectedChar) {
      toast.error('No hay personaje seleccionado');
      return;
    }
    
    const dice = rollDice();
    
    const newPosition = (selectedChar.position + dice) % 30;
    const updatedChars = gameState.playerCharacters.map(c =>
      c.id === selectedChar.id ? { ...c, position: newPosition } : c
    );
    
    const cell = gameState.board[newPosition];
    let message = `Moviste a ${selectedChar.name} a la casilla ${newPosition}`;
    let updatedCards = [...gameState.playerCards];
    
    // Check cell type
    if (cell.type === 'special') {
      if (gameState.playerCards.length < 2) {
        const newCard = getRandomWeaponCard();
        updatedCards.push(newCard);
        message += ` y obtuviste ${newCard.name}!`;
        toast.success(`¡Carta obtenida: ${newCard.name}!`);
      }
    }
    
    setGameState({
      ...gameState,
      playerCharacters: updatedChars,
      playerCards: updatedCards,
      diceResult: dice,
      selectedCharacter: selectedChar.id,
      actionPhase: 'action',
      message,
    });
  };

  // Handle ability dice roll for capturing points
  const handleRollAbilityDice = () => {
    if (gameState.captureAttemptsThisTurn >= 2) {
      toast.error('Ya intentaste capturar 2 veces este turno');
      return;
    }
    
    const result = rollAbilityDice();
    const selectedChar = gameState.playerCharacters.find(c => c.id === gameState.selectedCharacter);
    
    if (!selectedChar) return;
    
    const cell = gameState.board[selectedChar.position];
    const newAttempts = gameState.captureAttemptsThisTurn + 1;
    
    if (cell.type === 'controlPoint' && result === 'Transformer') {
      const updatedBoard = gameState.board.map(c =>
        c.id === cell.id ? { ...c, owner: 'player' as const } : c
      );
      
      setGameState({
        ...gameState,
        board: updatedBoard,
        abilityDiceResult: result,
        captureAttemptsThisTurn: newAttempts,
        message: `¡Capturaste el punto ${cell.controlPoint}!`,
      });
      
      toast.success(`¡Punto ${cell.controlPoint} capturado!`);
    } else {
      setGameState({
        ...gameState,
        abilityDiceResult: result,
        captureAttemptsThisTurn: newAttempts,
        message: result === 'Transformer' 
          ? 'Éxito, pero no hay punto que capturar' 
          : `Fallo al intentar capturar (${newAttempts}/2 intentos)`,
      });
      
      if (newAttempts >= 2) {
        toast.warning('Alcanzaste el máximo de intentos de captura');
      } else {
        toast.info(`Intento ${newAttempts}/2`);
      }
    }
  };

  // Handle using weapon card
  const handleUseCard = (cardIndex: number) => {
    const card = gameState.playerCards[cardIndex];
    const selectedChar = gameState.playerCharacters.find(c => c.id === gameState.selectedCharacter);
    
    if (!card || !selectedChar) return;
    
    // Find adjacent AI character to attack
    const targetAI = gameState.aiCharacters.find(ai =>
      ai.isAlive && isAdjacentPosition(selectedChar.position, ai.position)
    );
    
    if (targetAI) {
      const damagedAI = applyDamage(targetAI, card.damage, card.shieldPiercing);
      const updatedAIChars = gameState.aiCharacters.map(c =>
        c.id === targetAI.id ? damagedAI : c
      );
      
      const updatedCards = gameState.playerCards.filter((_, i) => i !== cardIndex);
      
      // If attack was chosen, end the turn after attacking
      const shouldEndPhase = gameState.selectedAction === 'attack';
      
      setGameState({
        ...gameState,
        aiCharacters: updatedAIChars,
        playerCards: updatedCards,
        actionPhase: shouldEndPhase ? 'end-turn' : 'action',
        message: `¡Atacaste a ${targetAI.name} con ${card.name}! Daño: ${card.damage}${shouldEndPhase ? '. Turno terminado.' : ''}`,
      });
      
      toast.success(`¡Ataque exitoso!${!damagedAI.isAlive ? ' Enemigo eliminado!' : ''}`);
      
      // If attack was the chosen action, auto end turn after a delay
      if (shouldEndPhase) {
        setTimeout(() => {
          handleEndTurn();
        }, 1500);
      }
    } else {
      toast.error('No hay enemigos adyacentes para atacar');
    }
  };

  // Handle benefit selection
  const handleBenefit = (type: 'health' | 'shield') => {
    if (gameState.benefitUsedThisTurn) {
      toast.error('Ya usaste el beneficio este turno');
      return;
    }
    
    const selectedChar = gameState.playerCharacters.find(c => c.id === gameState.selectedCharacter);
    
    if (!selectedChar) return;
    
    const cell = gameState.board[selectedChar.position];
    
    if (cell.type === 'benefit') {
      const updatedChar = type === 'health' ? healCharacter(selectedChar) : addShield(selectedChar);
      const updatedChars = gameState.playerCharacters.map(c =>
        c.id === selectedChar.id ? updatedChar : c
      );
      
      setGameState({
        ...gameState,
        playerCharacters: updatedChars,
        benefitUsedThisTurn: true,
        message: `¡${selectedChar.name} recibió +1 ${type === 'health' ? 'Vida' : 'Escudo'}!`,
      });
      
      toast.success(`+1 ${type === 'health' ? 'Vida' : 'Escudo'}`);
    }
  };

  // Handle end turn
  const handleEndTurn = () => {
    // Check win condition
    const winner = checkWinCondition(gameState.playerCharacters, gameState.aiCharacters, gameState.board);
    
    if (winner) {
      setGameState({
        ...gameState,
        phase: 'game-over',
        winner,
      });
      return;
    }
    
    // Check if event should trigger
    let eventActivated = gameState.eventActivated;
    let currentEvent = gameState.currentEvent;
    
    if (gameState.turnCount >= 8 && !gameState.eventActivated) {
      currentEvent = getRandomEvent();
      eventActivated = true;
      toast.warning(`¡Evento activado: ${currentEvent.name}!`);
      
      // Apply event effects
      let updatedPlayerChars = [...gameState.playerCharacters];
      let updatedAIChars = [...gameState.aiCharacters];
      
      if (currentEvent.type === 'global-damage') {
        updatedPlayerChars = updatedPlayerChars.map(c => ({
          ...c,
          shield: Math.max(0, c.shield - 1),
        }));
        updatedAIChars = updatedAIChars.map(c => ({
          ...c,
          shield: Math.max(0, c.shield - 1),
        }));
      } else if (currentEvent.type === 'meteorite') {
        updatedPlayerChars = updatedPlayerChars.map(c => ({
          ...c,
          health: Math.max(0, c.health - 1),
          isAlive: c.health - 1 > 0,
        }));
        updatedAIChars = updatedAIChars.map(c => ({
          ...c,
          health: Math.max(0, c.health - 1),
          isAlive: c.health - 1 > 0,
        }));
      } else if (currentEvent.type === 'energy-boost') {
        updatedPlayerChars = updatedPlayerChars.map(c => healCharacter(c));
        updatedAIChars = updatedAIChars.map(c => healCharacter(c));
      }
      
      setGameState(prev => ({
        ...prev,
        playerCharacters: updatedPlayerChars,
        aiCharacters: updatedAIChars,
        eventActivated,
        currentEvent,
      }));
    }
    
    // Switch to AI turn
    setGameState(prev => ({
      ...prev,
      turn: 'ai',
      turnCount: prev.turn === 'ai' ? prev.turnCount + 1 : prev.turnCount,
      actionPhase: 'select-character',
      diceResult: null,
      abilityDiceResult: null,
      selectedCharacter: null,
      selectedAction: null,
      benefitUsedThisTurn: false,
      captureAttemptsThisTurn: 0,
      message: 'Turno de la IA...',
    }));
  };

  // AI Turn Logic
  useEffect(() => {
    if (gameState.turn === 'ai' && gameState.phase === 'game') {
      const timeout = setTimeout(() => {
        executeAITurn();
      }, 1500);
      
      return () => clearTimeout(timeout);
    }
  }, [gameState.turn, gameState.phase]);

  const executeAITurn = () => {
    const aliveAIChars = gameState.aiCharacters.filter(c => c.isAlive);
    
    if (aliveAIChars.length === 0) {
      handleEndTurn();
      return;
    }
    
    // Select character (prioritize lowest health)
    const selectedChar = aliveAIChars.sort((a, b) => a.health - b.health)[0];
    
    // Roll dice and move
    const dice = rollDice();
    const newPosition = (selectedChar.position + dice) % 30;
    
    let updatedAIChars = gameState.aiCharacters.map(c =>
      c.id === selectedChar.id ? { ...c, position: newPosition } : c
    );
    
    let updatedPlayerChars = [...gameState.playerCharacters];
    let updatedBoard = [...gameState.board];
    let updatedAICards = [...gameState.aiCards];
    let message = `IA movió ${selectedChar.name} a la casilla ${newPosition}`;
    
    const cell = gameState.board[newPosition];
    
    // Check for special cell
    if (cell.type === 'special' && gameState.aiCards.length < 2) {
      const newCard = getRandomWeaponCard();
      updatedAICards.push(newCard);
      message += ' y obtuvo un arma';
    }
    
    // Check for benefit
    if (cell.type === 'benefit') {
      const benefitType = getAIBenefitChoice(selectedChar);
      const updatedChar = benefitType === 'health' 
        ? healCharacter(selectedChar) 
        : addShield(selectedChar);
      updatedAIChars = updatedAIChars.map(c =>
        c.id === selectedChar.id ? updatedChar : c
      );
      message += ` y recibió +1 ${benefitType === 'health' ? 'Vida' : 'Escudo'}`;
    }
    
    // Check for adjacent player to attack
    const adjacentPlayer = gameState.playerCharacters.find(p =>
      p.isAlive && isAdjacentPosition(newPosition, p.position)
    );
    
    if (adjacentPlayer && updatedAICards.length > 0) {
      const card = updatedAICards[0];
      const damagedPlayer = applyDamage(adjacentPlayer, card.damage, card.shieldPiercing);
      updatedPlayerChars = updatedPlayerChars.map(c =>
        c.id === adjacentPlayer.id ? damagedPlayer : c
      );
      updatedAICards = updatedAICards.slice(1);
      message += ` y atacó a ${adjacentPlayer.name}!`;
      toast.error(`¡La IA te atacó con ${card.name}!`);
    }
    
    // Try to capture control point
    if (cell.type === 'controlPoint' && cell.owner !== 'ai') {
      const abilityResult = rollAbilityDice();
      if (abilityResult === 'Transformer') {
        updatedBoard = gameState.board.map(c =>
          c.id === cell.id ? { ...c, owner: 'ai' as const } : c
        );
        message += ` y capturó el punto ${cell.controlPoint}!`;
        toast.warning(`¡La IA capturó el punto ${cell.controlPoint}!`);
      }
    }
    
    setGameState(prev => ({
      ...prev,
      aiCharacters: updatedAIChars,
      playerCharacters: updatedPlayerChars,
      board: updatedBoard,
      aiCards: updatedAICards,
      message,
      diceResult: dice,
    }));
    
    // End AI turn
    setTimeout(() => {
      const winner = checkWinCondition(updatedPlayerChars, updatedAIChars, updatedBoard);
      
      if (winner) {
        setGameState(prev => ({
          ...prev,
          phase: 'game-over',
          winner,
        }));
      } else {
        setGameState(prev => ({
          ...prev,
          turn: 'player',
          turnCount: prev.turnCount + 1,
          actionPhase: 'select-character',
          diceResult: null,
          abilityDiceResult: null,
          selectedCharacter: null,
          selectedAction: null,
          benefitUsedThisTurn: false,
          captureAttemptsThisTurn: 0,
          message: 'Tu turno. Selecciona un personaje.',
        }));
      }
    }, 2000);
  };

  // Handle restart
  const handleRestart = () => {
    setGameState({
      phase: 'faction-selection',
      turn: 'player',
      turnCount: 1,
      playerFaction: null,
      aiFaction: null,
      playerCharacters: [],
      aiCharacters: [],
      board: [],
      playerCards: [],
      aiCards: [],
      diceResult: null,
      abilityDiceResult: null,
      selectedCharacter: null,
      actionPhase: 'select-character',
      selectedAction: null,
      winner: null,
      eventActivated: false,
      currentEvent: null,
      message: 'Selecciona tu facción para comenzar',
      benefitUsedThisTurn: false,
      captureAttemptsThisTurn: 0,
    });
  };

  // Check conditions for actions
  const canRollDice = gameState.turn === 'player' && 
    gameState.actionPhase === 'roll-dice' &&
    gameState.diceResult === null &&
    gameState.selectedCharacter !== null;
  
  const canUseCard = gameState.turn === 'player' && 
    gameState.actionPhase === 'action' &&
    gameState.playerCards.length > 0;
  
  const selectedChar = gameState.playerCharacters.find(c => c.id === gameState.selectedCharacter);
  const currentCell = selectedChar ? gameState.board[selectedChar.position] : null;
  
  const canCapture = gameState.turn === 'player' &&
    gameState.actionPhase === 'action' &&
    currentCell?.type === 'controlPoint' &&
    currentCell.owner !== 'player' &&
    gameState.captureAttemptsThisTurn < 2;
  
  const canBenefit = gameState.turn === 'player' &&
    gameState.actionPhase === 'action' &&
    currentCell?.type === 'benefit' &&
    !gameState.benefitUsedThisTurn;

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white">
      <Toaster position="top-center" richColors />
      
      {gameState.phase === 'faction-selection' && (
        <FactionSelection onSelectFaction={handleFactionSelection} />
      )}
      
      {gameState.phase === 'game' && (
        <div className="container mx-auto p-4">
          <div className="grid grid-cols-1 lg:grid-cols-4 gap-6 mb-6">
            <div className="lg:col-span-1">
              <CharacterPanel
                characters={gameState.playerCharacters}
                title={`${gameState.playerFaction ? FACTION_NAMES[gameState.playerFaction] : 'Jugador'}`}
                isPlayer={true}
              />
            </div>
            
            <div className="lg:col-span-2">
              <GameBoard
                board={gameState.board}
                playerCharacters={gameState.playerCharacters}
                aiCharacters={gameState.aiCharacters}
              />
            </div>
            
            <div className="lg:col-span-1">
              <CharacterPanel
                characters={gameState.aiCharacters}
                title={`${gameState.aiFaction ? FACTION_NAMES[gameState.aiFaction] : 'IA'}`}
                isPlayer={false}
              />
            </div>
          </div>
          
          <div className="max-w-2xl mx-auto">
            <ActionPanel
              turn={gameState.turn}
              turnCount={gameState.turnCount}
              actionPhase={gameState.actionPhase}
              diceResult={gameState.diceResult}
              abilityDiceResult={gameState.abilityDiceResult}
              playerCards={gameState.playerCards}
              playerCharacters={gameState.playerCharacters}
              selectedCharacter={gameState.selectedCharacter}
              message={gameState.message}
              onSelectCharacter={handleSelectCharacter}
              onChooseAction={handleChooseAction}
              onRollDice={handleRollDice}
              onRollAbilityDice={handleRollAbilityDice}
              onUseCard={handleUseCard}
              onEndTurn={handleEndTurn}
              onBenefit={handleBenefit}
              canRollDice={canRollDice}
              canUseCard={canUseCard}
              canCapture={canCapture}
              canBenefit={canBenefit}
              captureAttemptsThisTurn={gameState.captureAttemptsThisTurn}
            />
          </div>
          
          {gameState.currentEvent && (
            <div className="mt-6 max-w-2xl mx-auto bg-orange-900/50 border-2 border-orange-500 rounded-xl p-4 text-center">
              <div className="text-xl mb-2">⚡ Evento: {gameState.currentEvent.name}</div>
              <div className="text-sm text-gray-300">{gameState.currentEvent.description}</div>
            </div>
          )}
        </div>
      )}
      
      {gameState.phase === 'game-over' && gameState.winner && (
        <GameOverScreen winner={gameState.winner} onRestart={handleRestart} />
      )}
    </div>
  );
}
